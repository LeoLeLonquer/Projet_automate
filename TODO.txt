

ERREURS A CORRIGER :
- Si aucune affectation au début de test.c alors problème de réécriture des JMP

-Problème avec le token Main
        résolution en ajoutant une fonction spéciale main dans la grammaire
        => problème de shiftreduce

-pas de reconnaissance de ce type int c = (a+b)

-pas la possibilité de faire un while dans un while => pb viens de WhileDeb

=============================================== 


-Bien réfléchir à l'implémentation de la pile des adresses de retour 
    sol1 : 
	AVANT APPEL de fonction : -sauvegarder l'état courant (adr de retour présente) en décalant les sauvegardes d'adresse de retour (équivalent while) (CP adr1 dans adr 2) 
				  -créer une nouvelle adresse de retour et la stocker dans adrRet1 (adrRet1 seulement) 
				  - jumpé dans la fonction
	APRES APPEL DE FONCTION : -recharger l'état précédent en ramenant l'ancienne adr de retour dans adrRet1
				  -continuer l'exécution


    sol2 :   -chaque déclaration de fonction crée une adresse de retour
             -chaque invocation de fonction crée une adresse de retour 

done -Faire la table des instructions qui nous servira pour sauvegarder les blocs if et les blocs while

done -Demander dans Exp: TId où retrouve-t-on la valeur de TId?


Pour le tableau de branchement :
	-dans les débuts de branchement (TIf, While…) mettre les instructions
		ajouter_branche();
               printf("\n");
               increment_ligne(1);
		increment_instr(prof,1);
		prof++;
	-dans les corps de blocs, à chaque fois qu’une instruction est printée, utiliser
		increment_ligne(?)
		increment_instr(prof,?)
	-à la fin des branchements 
		utiliser retirer_branche(prof);



-Dans le makefile, changer la compilation des test en quelque ligne grâce à :
test_% : test_tab_%.c tab_.o
		gcc $^ -o $@
